const { Client } = require('@mathieuc/tradingview');
const nodemailer = require('nodemailer');
const emailConfig = require('./email-config');

const client = new Client();

// T·∫°o transporter cho email
const transporter = nodemailer.createTransport({
    service: emailConfig.service,
    auth: emailConfig.auth
});

// Bi·∫øn l∆∞u tr·ªØ d·ªØ li·ªáu b√°o c√°o
let reportData = {
    startTime: new Date(),
    updates: [],
    currentPrice: null,
    highPrice: null,
    lowPrice: null,
    symbol: null,
    previousPrice: null,
    lastEmailSent: null // Th√™m bi·∫øn ƒë·ªÉ theo d√µi l·∫ßn g·ª≠i email cu·ªëi
};

// H√†m t·∫°o n·ªôi dung email
function generateEmailReport() {
    const now = new Date();
    const duration = Math.floor((now - reportData.startTime) / 1000 / 60); // ph√∫t
    
    let html = `
    <h2>‚òï Coffee Robusta Price Report</h2>
    <p><strong>Symbol:</strong> ${reportData.symbol || 'N/A'}</p>
    <p><strong>Report Time:</strong> ${now.toLocaleString('vi-VN', { timeZone: 'Asia/Ho_Chi_Minh' })}</p>
    <p><strong>Monitoring Duration:</strong> ${duration} minutes</p>
    
    <h3>üìä Current Market Data</h3>
    <table border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse;">
        <tr><td><strong>Current Price</strong></td><td>$${reportData.currentPrice?.toFixed(2) || 'N/A'}</td></tr>
        <tr><td><strong>High</strong></td><td>$${reportData.highPrice?.toFixed(2) || 'N/A'}</td></tr>
        <tr><td><strong>Low</strong></td><td>$${reportData.lowPrice?.toFixed(2) || 'N/A'}</td></tr>
    </table>
    
    <h3>üìà Recent Updates</h3>
    <table border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse;">
        <tr>
            <th>Time</th>
            <th>Price</th>
            <th>Change</th>
            <th>Change %</th>
        </tr>
    `;
    
    // L·∫•y 10 update g·∫ßn nh·∫•t
    const recentUpdates = reportData.updates.slice(-10);
    recentUpdates.forEach(update => {
        const changeColor = update.change >= 0 ? 'green' : 'red';
        html += `
        <tr>
            <td>${update.timestamp}</td>
            <td>$${update.price.toFixed(2)}</td>
            <td style="color: ${changeColor}">$${update.change.toFixed(2)}</td>
            <td style="color: ${changeColor}">${update.changePercent}%</td>
        </tr>
        `;
    });
    
    html += `
    </table>
    <p><em>Generated by Coffee Trading Bot - ${new Date().toISOString()}</em></p>
    `;
    
    return html;
}

// H√†m g·ª≠i email b√°o c√°o
async function sendEmailReport() {
    try {
        const mailOptions = {
            from: emailConfig.from,
            to: emailConfig.to,
            subject: `‚òï Coffee Robusta Price Report - ${new Date().toLocaleDateString('vi-VN')}`,
            html: generateEmailReport()
        };
        
        const info = await transporter.sendMail(mailOptions);
        console.log('üìß Email report sent successfully:', info.messageId);
    } catch (error) {
        console.error('‚ùå Failed to send email:', error.message);
    }
}

// H√†m g·ª≠i c·∫£nh b√°o gi√°
async function sendPriceAlert(price, type) {
    try {
        const subject = type === 'high' ? 
            `üö® HIGH PRICE ALERT - Coffee Robusta: $${price.toFixed(2)}` :
            `‚ö†Ô∏è LOW PRICE ALERT - Coffee Robusta: $${price.toFixed(2)}`;
            
        const html = `
        <h2>${type === 'high' ? 'üö®' : '‚ö†Ô∏è'} Price Alert</h2>
        <p><strong>Symbol:</strong> ${reportData.symbol}</p>
        <p><strong>Current Price:</strong> $${price.toFixed(2)}</p>
        <p><strong>Alert Type:</strong> ${type.toUpperCase()} PRICE</p>
        <p><strong>Threshold:</strong> $${emailConfig.priceAlerts.thresholds[type]}</p>
        <p><strong>Time:</strong> ${new Date().toLocaleString('vi-VN', { timeZone: 'Asia/Ho_Chi_Minh' })}</p>
        `;
        
        const mailOptions = {
            from: emailConfig.from,
            to: emailConfig.to,
            subject: subject,
            html: html
        };
        
        const info = await transporter.sendMail(mailOptions);
        console.log(`üìß Price alert sent: ${type.toUpperCase()} - $${price.toFixed(2)}`);
    } catch (error) {
        console.error('‚ùå Failed to send price alert:', error.message);
    }
}

async function startRealtimeQuotes() {
    try {
        console.log('üöÄ Starting Coffee Robusta RC1 Realtime Quotes...');
        console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
          // T·∫°o session
        const chart = new client.Session.Chart();
          // Symbol ho·∫°t ƒë·ªông t·ªët cho Robusta Coffee       
           const workingSymbols = [
            'ICEEUR:RC1!',    // Robusta Coffee Continuous Contract - ICE Europe
            'ICEEUR:RCH2025', // Robusta Coffee March 2025
            'ICEEUR:RCK2025', // Robusta Coffee May 2025
            'ICEEUR:RCN2025', // Robusta Coffee July 2025
            'ICEEUR:RCU2025', // Robusta Coffee September 2025
            'ICEEUR:RCX2025', // Robusta Coffee November 2025
            'ICEEUR:RCF2026', // Robusta Coffee January 2026
            'NYSE:JO',        // Coffee ETF (backup)
            'NASDAQ:SBUX',    // Starbucks (backup)
        ];
        
        let currentSymbolIndex = 0;
        let connectedSymbol = null;
        let isConnected = false;
        
        function tryNextSymbol() {
            if (currentSymbolIndex >= workingSymbols.length) {
                console.error('‚ùå Kh√¥ng th·ªÉ k·∫øt n·ªëi v·ªõi b·∫•t k·ª≥ symbol n√†o');
                return;
            }
            
            const symbol = workingSymbols[currentSymbolIndex];
            console.log(`üîç ƒêang th·ª≠ symbol: ${symbol}`);
            
            chart.setMarket(symbol, {
                timeframe: '1',
                range: 100,
            });
            
            currentSymbolIndex++;
        }
        
        // B·∫Øt ƒë·∫ßu v·ªõi symbol ƒë·∫ßu ti√™n
        tryNextSymbol();
        
        // L·∫Øng nghe d·ªØ li·ªáu realtime
        chart.onSymbolLoaded(() => {
            connectedSymbol = workingSymbols[currentSymbolIndex-1];
            isConnected = true;
            console.log(`‚úÖ Symbol ${connectedSymbol} loaded successfully`);
            console.log('üéØ B·∫Øt ƒë·∫ßu nh·∫≠n d·ªØ li·ªáu realtime...');
        });

        chart.onUpdate(() => {
            if (!isConnected) return;
            
            const data = chart.periods[0];
            if (data && connectedSymbol) {
                const timestamp = new Date().toLocaleString('vi-VN', {
                    timeZone: 'Asia/Ho_Chi_Minh'
                });
                
                // T√≠nh to√°n thay ƒë·ªïi gi√°
                const prevClose = data.open;
                const change = data.close - prevClose;
                const changePercent = ((change / prevClose) * 100).toFixed(2);
                const changeSymbol = change >= 0 ? 'üìà' : 'üìâ';
                
                console.log(`\nüìä [${timestamp}] Coffee Robusta - ${connectedSymbol}`);
                console.log(`üí∞ Current Price: $${data.close.toFixed(2)}`);
                console.log(`${changeSymbol} Change: $${change.toFixed(2)} (${changePercent}%)`);
                console.log(`üìä High: $${data.max.toFixed(2)} | Low: $${data.min.toFixed(2)}`);
                console.log(`üîÑ Volume: ${data.volume || 'N/A'}`);
                console.log(`üïê Open: $${data.open.toFixed(2)}`);
                console.log('‚ïê'.repeat(60));

                // C·∫≠p nh·∫≠t d·ªØ li·ªáu b√°o c√°o
                reportData.updates.push({
                    timestamp,
                    price: data.close,
                    change,
                    changePercent,
                    high: data.max,
                    low: data.min,
                    volume: data.volume || 'N/A',
                    open: data.open
                });
                reportData.currentPrice = data.close;
                reportData.highPrice = data.max;
                reportData.lowPrice = data.min;
                reportData.symbol = connectedSymbol;

                // Ki·ªÉm tra c·∫£nh b√°o gi√°
                if (emailConfig.priceAlerts.enabled) {
                    if (data.close >= emailConfig.priceAlerts.thresholds.high) {
                        sendPriceAlert(data.close, 'high');
                    } else if (data.close <= emailConfig.priceAlerts.thresholds.low) {
                        sendPriceAlert(data.close, 'low');
                    }
                }
            }
        });

        chart.onError((error) => {
            if (isConnected) {
                console.error(`‚ùå Connection lost for ${connectedSymbol}:`, error);
                console.log('üîÑ ƒêang th·ª≠ k·∫øt n·ªëi l·∫°i...');
                isConnected = false;
                setTimeout(() => {
                    tryNextSymbol();
                }, 3000);
            } else {
                console.error(`‚ùå Chart Error for ${workingSymbols[currentSymbolIndex-1]}:`, error);
                console.log('üîÑ Th·ª≠ symbol ti·∫øp theo...');
                setTimeout(() => {
                    tryNextSymbol();
                }, 2000);
            }
        });

        // Gi·ªØ ch∆∞∆°ng tr√¨nh ch·∫°y
        process.on('SIGINT', () => {
            console.log('\nüõë Stopping realtime quotes...');
            chart.delete();
            client.end();
            process.exit(0);
        });

        console.log('üì° Waiting for realtime data... (Press Ctrl+C to stop)');
        
    } catch (error) {
        console.error('‚ùå Error:', error);
    }
}

// H√†m ki·ªÉm tra v√† g·ª≠i b√°o c√°o h√†ng ng√†y
function checkAndSendDailyReport() {
    const now = new Date();
    const today = now.toDateString(); // L·∫•y ng√†y hi·ªán t·∫°i d∆∞·ªõi d·∫°ng string
    
    // Ki·ªÉm tra xem ƒë√£ g·ª≠i b√°o c√°o h√¥m nay ch∆∞a
    if (reportData.lastEmailSent !== today && reportData.currentPrice) {
        console.log('üìß Sending daily report...');
        sendEmailReport();
        reportData.lastEmailSent = today;
    }
}

// H√†m l√™n l·ªãch g·ª≠i b√°o c√°o h√†ng ng√†y v√†o gi·ªù ƒë√£ c·∫•u h√¨nh
function scheduleDailyReport() {
    const now = new Date();
    const reportHour = emailConfig.dailyReportTime || 8; // M·∫∑c ƒë·ªãnh 8:00 AM
    const nextReportTime = new Date();
    nextReportTime.setHours(reportHour, 0, 0, 0);
    
    // N·∫øu ƒë√£ qua gi·ªù b√°o c√°o h√¥m nay, l√™n l·ªãch cho ng√†y mai
    if (now >= nextReportTime) {
        nextReportTime.setDate(nextReportTime.getDate() + 1);
    }
    
    const timeUntilNextReport = nextReportTime - now;
    
    setTimeout(() => {
        checkAndSendDailyReport();
        // Sau ƒë√≥ l·∫∑p l·∫°i m·ªói 24 gi·ªù
        setInterval(checkAndSendDailyReport, 24 * 60 * 60 * 1000);
    }, timeUntilNextReport);
    
    console.log(`üìß Daily report scheduled for ${reportHour}:00 AM (Next: ${nextReportTime.toLocaleString('vi-VN', { timeZone: 'Asia/Ho_Chi_Minh' })})`);
}

// Kh·ªüi t·∫°o k·∫øt n·ªëi
client.onConnected(() => {
    console.log('üîó Connected to TradingView');
    startRealtimeQuotes();
    
    // L√™n l·ªãch g·ª≠i b√°o c√°o h√†ng ng√†y v√†o 8:00 AM
    scheduleDailyReport();
});

client.onDisconnected(() => {
    console.log('üîå Disconnected from TradingView');
});

client.onError((error) => {
    console.error('‚ùå Connection Error:', error);
});